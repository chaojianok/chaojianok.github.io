<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chaojianok</title>
  
  <subtitle>Chaojianok&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chaojianok.github.io/"/>
  <updated>2019-06-18T07:54:32.481Z</updated>
  <id>https://chaojianok.github.io/</id>
  
  <author>
    <name>Chaojian Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka环境搭建</title>
    <link href="https://chaojianok.github.io/Kafka%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://chaojianok.github.io/Kafka环境搭建/</id>
    <published>2019-06-18T07:50:39.000Z</published>
    <updated>2019-06-18T07:54:32.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章基于Linux平台介绍Kafka的安装和初体验。</p></blockquote><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>下载并解压。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/kafka/2.2.0/kafka_2.12-2.2.0.tgz</span><br><span class="line">tar -xzf kafka_2.12-2.2.0.tgz</span><br><span class="line">cd kafka_2.12-2.2.0</span><br></pre></td></tr></table></figure></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>Kafka依赖ZooKeeper，这里首先安装并启动ZooKeeper服务。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/stable/apache-zookeeper-3.5.5-bin.tar.gz</span><br><span class="line">tar -xzf apache-zookeeper-3.5.5.tar.gz</span><br><span class="line">cd apache-zookeeper-3.5.5</span><br><span class="line">cp conf/zoo_sample.cfg conf/zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash">启动zookeeper服务</span></span><br><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure></p><p>现在启动Kafka服务。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure></p><h2 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h2><p>创建一个名为“test”的主题，它只包含一个分区和一个副本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --partitions 1 --replication-factor 1 --topic test</span><br></pre></td></tr></table></figure></p><p>查看已经创建好的主题。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure></p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>Kafka附带一个命令行客户端，它将从文件或标准输入中获取输入，并将其作为消息发送到Kafka集群。默认情况下，每行将作为单独的消息发送。<br>运行生产者，然后在控制台中输入一些消息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure></p><h2 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h2><p>在命令行终端开启一个Kafka的消息消费者，它会将消息转储到标准输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章基于Linux平台介绍Kafka的安装和初体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;下载代码&quot;&gt;&lt;a href=&quot;#下载代码&quot; class=&quot;headerlink&quot; title=&quot;下载代码&quot;&gt;&lt;/a&gt;下载代码&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="Kafka" scheme="https://chaojianok.github.io/categories/Kafka/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Kafka" scheme="https://chaojianok.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Flink源码分析 - 剖析一个简单的Flink程序</title>
    <link href="https://chaojianok.github.io/Flink%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%89%96%E6%9E%90%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Flink%E7%A8%8B%E5%BA%8F/"/>
    <id>https://chaojianok.github.io/Flink源码分析-剖析一个简单的Flink程序/</id>
    <published>2019-06-04T00:51:59.000Z</published>
    <updated>2019-06-05T05:34:14.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这之前已经介绍了<a href="https://www.toutiao.com/a6691941792230670860/" target="_blank" rel="noopener">如何在本地搭建Flink环境和如何创建Flink应用</a>和<a href="https://www.toutiao.com/a6685975180734366220/" target="_blank" rel="noopener">如何构建Flink源码</a>，这篇文章用官方提供的SocketWindowWordCount例子来解析一下一个常规Flink程序的每一个基本步骤。</p></blockquote><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketWindowWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// the host and the port to connect to</span></span><br><span class="line">        <span class="keyword">final</span> String hostname;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line">            hostname = params.has(<span class="string">"hostname"</span>) ? params.get(<span class="string">"hostname"</span>) : <span class="string">"localhost"</span>;</span><br><span class="line">            port = params.getInt(<span class="string">"port"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"No port specified. Please run 'SocketWindowWordCount "</span> +</span><br><span class="line">                    <span class="string">"--hostname &lt;hostname&gt; --port &lt;port&gt;', where hostname (localhost by default) "</span> +</span><br><span class="line">                    <span class="string">"and port is the address of the text server"</span>);</span><br><span class="line">            System.err.println(<span class="string">"To start a simple text server, run 'netcat -l &lt;port&gt;' and "</span> +</span><br><span class="line">                    <span class="string">"type the input text into the command line"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get the execution environment</span></span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// get input data by connecting to the socket</span></span><br><span class="line">        DataStream&lt;String&gt; text = env.socketTextStream(hostname, port, <span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">// parse the data, group it, window it, and aggregate the counts</span></span><br><span class="line">        DataStream&lt;WordWithCount&gt; windowCounts = text</span><br><span class="line">                .flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, WordWithCount&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;WordWithCount&gt; out)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                            out.collect(<span class="keyword">new</span> WordWithCount(word, <span class="number">1L</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(<span class="string">"word"</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;WordWithCount&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> WordWithCount <span class="title">reduce</span><span class="params">(WordWithCount a, WordWithCount b)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> WordWithCount(a.word, a.count + b.count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// print the results with a single thread, rather than in parallel</span></span><br><span class="line">        windowCounts.print().setParallelism(<span class="number">1</span>);</span><br><span class="line">        env.execute(<span class="string">"Socket Window WordCount"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Data type for words with count.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordWithCount</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String word;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordWithCount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordWithCount</span><span class="params">(String word, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> word + <span class="string">" : "</span> + count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个是官网的<code>SocketWindowWordCount</code>程序示例，它首先从命令行中获取socket连接的host和port，然后获取执行环境、从socket连接中读取数据、解析和转换数据，最后输出结果数据。<br>每个Flink程序都包含以下几个相同的基本部分：  </p><ol><li>获得一个execution environment，</li><li>加载/创建初始数据，</li><li>指定此数据的转换，</li><li>指定放置计算结果的位置，</li><li>触发程序执行</li></ol><h2 id="Flink执行环境"><a href="#Flink执行环境" class="headerlink" title="Flink执行环境"></a>Flink执行环境</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure><p>Flink程序都是从这句代码开始，这行代码会返回一个执行环境，表示当前执行程序的上下文。如果程序是独立调用的，则此方法返回一个由<code>createLocalEnvironment()</code>创建的本地执行环境<code>LocalStreamEnvironment</code>。从其源码里可以看出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamExecutionEnvironment <span class="title">getExecutionEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (contextEnvironmentFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> contextEnvironmentFactory.createExecutionEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="keyword">if</span> (env <span class="keyword">instanceof</span> ContextEnvironment) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StreamContextEnvironment((ContextEnvironment) env);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (env <span class="keyword">instanceof</span> OptimizerPlanEnvironment || env <span class="keyword">instanceof</span> PreviewPlanEnvironment) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StreamPlanEnvironment(env);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createLocalEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取输入数据"><a href="#获取输入数据" class="headerlink" title="获取输入数据"></a>获取输入数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; text = env.socketTextStream(hostname, port, <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure><p>这个例子里的源数据来自于socket，这里会根据指定的socket配置创建socket连接，然后创建一个新数据流，包含从套接字无限接收的字符串，接收的字符串由系统的默认字符集解码。当socket连接关闭时，数据读取会立即终止。通过查看源码可以发现，这里实际上是通过指定的socket配置来构造一个<code>SocketTextStreamFunction</code>实例，然后源源不断的从socket连接里读取输入的数据创建数据流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataStreamSource&lt;String&gt; <span class="title">socketTextStream</span><span class="params">(String hostname, <span class="keyword">int</span> port, String delimiter, <span class="keyword">long</span> maxRetry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> addSource(<span class="keyword">new</span> SocketTextStreamFunction(hostname, port, delimiter, maxRetry),</span><br><span class="line"><span class="string">"Socket Stream"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SocketTextStreamFunction</code>的类继承关系如下：</p><p><img src="/images/flink/Diagram-SocketTextStreamFunction.png" alt="SocketTextStreamFunction类关系图"></p><p>可以看出<code>SocketTextStreamFunction</code>是<code>SourceFunction</code>的子类，<code>SourceFunction</code>是Flink中所有流数据源的基本接口。<code>SourceFunction</code>的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/streaming/api/functions/source/SourceFunction.java</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceFunction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;T&gt; ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SourceContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">collect</span><span class="params">(T element)</span></span>;</span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">collectWithTimestamp</span><span class="params">(T element, <span class="keyword">long</span> timestamp)</span></span>;</span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emitWatermark</span><span class="params">(Watermark mark)</span></span>;</span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">markAsTemporarilyIdle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getCheckpointLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SourceFunction</code>定义了<code>run</code>和<code>cancel</code>两个方法和<code>SourceContext</code>内部接口。</p><ul><li>run(SourceContex)：实现数据获取逻辑，并可以通过传入的参数ctx进行向下游节点的数据转发。 </li><li>cancel()：用来取消数据源，一般在run方法中，会存在一个循环来持续产生数据，cancel方法则可以使该循环终止。</li><li>SourceContext：source函数用于发出元素和可能的watermark的接口，返回source生成的元素的类型。</li></ul><p>了解了<code>SourceFunction</code>这个接口，再来看下<code>SocketTextStreamFunction</code>的具体实现（主要是<code>run</code>方法），逻辑就已经很清晰了，就是从指定的hostname和port持续不断的读取数据，按回车换行分隔符划分成一个个字符串，然后再将数据转发到下游。现在回到<code>StreamExecutionEnvironment</code>的<code>socketTextStream</code>方法，它通过调用<code>addSource</code>返回一个<code>DataStreamSource</code>实例。思考一下，例子里的<code>text</code>变量是<code>DataStream</code>类型，为什么源码里的返回类型却是<code>DataStreamSource</code>呢？这是因为<code>DataStream</code>是<code>DataStreamSource</code>的父类，下面的类关系图可以看出来，这也体现出了Java的多态的特性。</p><p><img src="/images/flink/Diagram-DataStreamSource.png" alt="DataStreamSource类关系图"></p><h2 id="数据流操作"><a href="#数据流操作" class="headerlink" title="数据流操作"></a>数据流操作</h2><p>对上面取到的DataStreamSource，进行<code>flatMap</code>、<code>keyBy</code>、<code>timeWindow</code>、<code>reduce</code>转换操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;WordWithCount&gt; windowCounts = text</span><br><span class="line">        .flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, WordWithCount&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;WordWithCount&gt; out)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                    out.collect(<span class="keyword">new</span> WordWithCount(word, <span class="number">1L</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .keyBy(<span class="string">"word"</span>)</span><br><span class="line">        .timeWindow(Time.seconds(<span class="number">5</span>))</span><br><span class="line">        .reduce(<span class="keyword">new</span> ReduceFunction&lt;WordWithCount&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WordWithCount <span class="title">reduce</span><span class="params">(WordWithCount a, WordWithCount b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WordWithCount(a.word, a.count + b.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>这段逻辑中，对上面取到的DataStreamSource数据流分别做了<code>flatMap</code>、<code>keyBy</code>、<code>timeWindow</code>、<code>reduce</code>四个转换操作，下面说一下<code>flatMap</code>转换，其他三个转换操作读者可以试着自己查看源码理解一下。  </p><p>先看一下<code>flatMap</code>方法的源码吧，如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/streaming/api/datastream/DataStream.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">flatMap</span><span class="params">(FlatMapFunction&lt;T, R&gt; flatMapper)</span> </span>&#123;</span><br><span class="line">TypeInformation&lt;R&gt; outType = TypeExtractor.getFlatMapReturnTypes(clean(flatMapper),</span><br><span class="line">getType(), Utils.getCallLocationName(), <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> transform(<span class="string">"Flat Map"</span>, outType, <span class="keyword">new</span> StreamFlatMap&lt;&gt;(clean(flatMapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面做了两件事，一是用反射拿到了<code>flatMap</code>算子的输出类型，二是生成了一个operator。flink流式计算的核心概念就是将数据从输入流一个个传递给operator进行链式处理，最后交给输出流的过程。对数据的每一次处理在逻辑上成为一个operator。上面代码中的最后一行<code>transform</code>方法的作用是返回一个<code>SingleOutputStreamOperator</code>，它继承了<code>Datastream</code>类并且定义了一些辅助方法，方便对流的操作。在返回之前，<code>transform</code>方法还把它注册到了执行环境中。下面这张图是一个由Flink程序映射为Streaming Dataflow的示意图：</p><p><img src="/images/flink/Flink介绍_基本编程模型.png" alt="Flink基本编程模型" title="Flink基本编程模型"></p><h2 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowCounts.print().setParallelism(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>每个Flink程序都是以source开始以sink结尾，这里的<code>print</code>方法就是把计算出来的结果sink标准输出流。在实际开发中，一般会通过官网提供的各种Connectors或者自定义的Connectors把计算好的结果数据sink到指定的地方，比如Kafka、HBase、FileSystem、Elasticsearch等等。这里的<code>setParallelism</code>是设置此接收器的并行度的，值必须大于零。</p><h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.execute(<span class="string">"Socket Window WordCount"</span>);</span><br></pre></td></tr></table></figure><p>Flink有远程模式和本地模式两种执行模式，这两种模式有一点不同，这里按本地模式来解析。先看下<code>execute</code>方法的源码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/streaming/api/environment/LocalStreamEnvironment.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// transform the streaming program into a JobGraph</span></span><br><span class="line">StreamGraph streamGraph = getStreamGraph();</span><br><span class="line">streamGraph.setJobName(jobName);</span><br><span class="line">JobGraph jobGraph = streamGraph.getJobGraph();</span><br><span class="line">jobGraph.setAllowQueuedScheduling(<span class="keyword">true</span>);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">configuration.addAll(jobGraph.getJobConfiguration());</span><br><span class="line">configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, <span class="string">"0"</span>);</span><br><span class="line"><span class="comment">// add (and override) the settings with what the user defined</span></span><br><span class="line">configuration.addAll(<span class="keyword">this</span>.configuration);</span><br><span class="line"><span class="keyword">if</span> (!configuration.contains(RestOptions.BIND_PORT)) &#123;</span><br><span class="line">configuration.setString(RestOptions.BIND_PORT, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());</span><br><span class="line">MiniClusterConfiguration cfg = <span class="keyword">new</span> MiniClusterConfiguration.Builder()</span><br><span class="line">.setConfiguration(configuration)</span><br><span class="line">.setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span><br><span class="line">.build();</span><br><span class="line"><span class="keyword">if</span> (LOG.isInfoEnabled()) &#123;</span><br><span class="line">LOG.info(<span class="string">"Running job on local embedded Flink mini cluster"</span>);</span><br><span class="line">&#125;</span><br><span class="line">MiniCluster miniCluster = <span class="keyword">new</span> MiniCluster(cfg);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">miniCluster.start();</span><br><span class="line">configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());</span><br><span class="line"><span class="keyword">return</span> miniCluster.executeJobBlocking(jobGraph);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">transformations.clear();</span><br><span class="line">miniCluster.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法包含三部分：将流程序转换为JobGraph、使用用户定义的内容添加（或覆盖）设置、启动一个miniCluster并执行任务。关于JobGraph暂先不讲，这里就只说一下执行任务，跟进下<code>return miniCluster.executeJobBlocking(jobGraph);</code>这行的源码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/runtime/minicluster/MiniCluster.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">executeJobBlocking</span><span class="params">(JobGraph job)</span> <span class="keyword">throws</span> JobExecutionException, InterruptedException </span>&#123;</span><br><span class="line">checkNotNull(job, <span class="string">"job is null"</span>);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;JobSubmissionResult&gt; submissionFuture = submitJob(job);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;JobResult&gt; jobResultFuture = submissionFuture.thenCompose(</span><br><span class="line">(JobSubmissionResult ignored) -&gt; requestJobResult(job.getJobID()));</span><br><span class="line"><span class="keyword">final</span> JobResult jobResult;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">jobResult = jobResultFuture.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> JobExecutionException(job.getJobID(), <span class="string">"Could not retrieve JobResult."</span>, ExceptionUtils.stripExecutionException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> JobExecutionException(job.getJobID(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的核心逻辑就是<code>final CompletableFuture&lt;JobSubmissionResult&gt; submissionFuture = submitJob(job);</code>，调用了<code>MiniCluster</code>类的<code>submitJob</code>方法，接着看这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/runtime/minicluster/MiniCluster.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobSubmissionResult&gt; <span class="title">submitJob</span><span class="params">(JobGraph jobGraph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;DispatcherGateway&gt; dispatcherGatewayFuture = getDispatcherGatewayFuture();</span><br><span class="line"><span class="comment">// we have to allow queued scheduling in Flip-6 mode because we need to request slots</span></span><br><span class="line"><span class="comment">// from the ResourceManager</span></span><br><span class="line">jobGraph.setAllowQueuedScheduling(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;InetSocketAddress&gt; blobServerAddressFuture = createBlobServerAddress(dispatcherGatewayFuture);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; jarUploadFuture = uploadAndSetJobFiles(blobServerAddressFuture, jobGraph);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; acknowledgeCompletableFuture = jarUploadFuture</span><br><span class="line">.thenCombine(</span><br><span class="line">dispatcherGatewayFuture,</span><br><span class="line">(Void ack, DispatcherGateway dispatcherGateway) -&gt; dispatcherGateway.submitJob(jobGraph, rpcTimeout))</span><br><span class="line">.thenCompose(Function.identity());</span><br><span class="line"><span class="keyword">return</span> acknowledgeCompletableFuture.thenApply(</span><br><span class="line">(Acknowledge ignored) -&gt; <span class="keyword">new</span> JobSubmissionResult(jobGraph.getJobID()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>Dispatcher</code>组件负责接收作业提交，持久化它们，生成JobManagers来执行作业并在主机故障时恢复它们。<code>Dispatcher</code>有两个实现，在本地环境下启动的是<code>MiniDispatcher</code>，在集群环境上启动的是<code>StandaloneDispatcher</code>。下面是类结构图：</p><p><img src="/images/flink/Diagram-MiniDispatcher.png" alt="MiniDispatcher类结构图"></p><p>这里的<code>Dispatcher</code>启动了一个<code>JobManagerRunner</code>，委托<code>JobManagerRunner</code>去启动该Job的<code>JobMaster</code>。对应的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/runtime/jobmaster/JobManagerRunner.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">verifyJobSchedulingStatusAndStartJobManager</span><span class="params">(UUID leaderSessionId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;JobSchedulingStatus&gt; jobSchedulingStatusFuture = getJobSchedulingStatus();</span><br><span class="line"><span class="keyword">return</span> jobSchedulingStatusFuture.thenCompose(</span><br><span class="line">jobSchedulingStatus -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (jobSchedulingStatus == JobSchedulingStatus.DONE) &#123;</span><br><span class="line"><span class="keyword">return</span> jobAlreadyDone();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> startJobMaster(leaderSessionId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JobMaster</code>经过一系列方法嵌套调用之后，最终执行到下面这段逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码目录：org/apache/flink/runtime/jobmaster/JobMaster.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExecutionGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">checkState(jobStatusListener == <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// register self as job status change listener</span></span><br><span class="line">jobStatusListener = <span class="keyword">new</span> JobManagerJobStatusListener();</span><br><span class="line">executionGraph.registerJobStatusListener(jobStatusListener);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executionGraph.scheduleForExecution();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">executionGraph.failGlobal(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里<code>executionGraph.scheduleForExecution();</code>调用了<code>ExecutionGraph</code>的启动方法。在Flink的图结构中，<code>ExecutionGraph</code>是真正被执行的地方，所以到这里为止，一个任务从提交到真正执行的流程就结束了，下面再回顾一下本地环境下的执行流程：  </p><ol><li>客户端执行<code>execute</code>方法；</li><li><code>MiniCluster</code>完成了大部分任务后把任务直接委派给<code>MiniDispatcher</code>；</li><li><code>Dispatcher</code>接收job之后，会实例化一个<code>JobManagerRunner</code>，然后用这个实例启动job；</li><li><code>JobManagerRunner</code>接下来把job交给<code>JobMaster</code>去处理；</li><li><code>JobMaster</code>使用<code>ExecutionGraph</code>的方法启动整个执行图，整个任务就启动起来了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在这之前已经介绍了&lt;a href=&quot;https://www.toutiao.com/a6691941792230670860/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何在本地搭建Flink环境和如何创建Flink应用&lt;/
      
    
    </summary>
    
      <category term="Flink" scheme="https://chaojianok.github.io/categories/Flink/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="https://chaojianok.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch常用操作</title>
    <link href="https://chaojianok.github.io/Elasticsearch%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://chaojianok.github.io/Elasticsearch常用操作/</id>
    <published>2019-05-22T01:58:32.000Z</published>
    <updated>2019-05-22T01:59:01.716Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇简单整理了Elasticsearch的一些常用的API。</p></blockquote><ol><li><p>新增一个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">'http://localhost:9200/index_name'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "settings": &#123;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "mappings": &#123;</span></span><br><span class="line"><span class="string">        "one": &#123;...&#125;,</span></span><br><span class="line"><span class="string">        "two": &#123;...&#125;,</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>删除一个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">"http://localhost:9200/index_name"</span></span><br></pre></td></tr></table></figure></li><li><p>删除多个索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">"http://localhost:9200/index_name1,index_name2"</span></span><br></pre></td></tr></table></figure></li><li><p>删除所有索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">"http://localhost:9200/_all"</span>  </span><br><span class="line">curl -X DELETE <span class="string">"http://localhost:9200/*"</span></span><br></pre></td></tr></table></figure></li><li><p>添加一条数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">'http://localhost:9200/index_name/type_name/id'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "title": "The title",</span></span><br><span class="line"><span class="string">  "text":  "The text ...",</span></span><br><span class="line"><span class="string">  "date":  "2019/01/01"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>删除单条数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">"http://localhost:9200/index_name/type_name/id"</span></span><br></pre></td></tr></table></figure></li><li><p>批量删除多条数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"http://localhost:9200/_bulk"</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;"delete":&#123;"_index":"index_name","_type":"main","_id":"1"&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;"delete":&#123;"_index":"index_name","_type":"main","_id":"2"&#125;&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure></li><li><p>删除所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"http://localhost:9200/index_name/type_name/_delete_by_query?conflicts=proceed"</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;"query": &#123;"match_all": &#123;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>修改索引setting</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'http://localhost:9200/index_name'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "settings": &#123;</span></span><br><span class="line"><span class="string">        "number_of_shards": 3,</span></span><br><span class="line"><span class="string">        "number_of_replicas": 0,</span></span><br><span class="line"><span class="string">        "index.mapping.total_fields.limit": 5000</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>索引重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'http://localhost:9200/_reindex'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "source": &#123;</span></span><br><span class="line"><span class="string">    "index": "index_name_old"</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  "dest": &#123;</span></span><br><span class="line"><span class="string">    "index": "index_name_new"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>手动迁移分片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">'http://localhost:9200/_cluster/settings'</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "transient": &#123;</span></span><br><span class="line"><span class="string">        "cluster.routing.allocation.enable": "none"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line">curl -X PUT <span class="string">'http://localhost:9200/_cluster/settings'</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "transient": &#123;</span></span><br><span class="line"><span class="string">        "cluster.routing.allocation.enable": "all"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line">curl -X POST <span class="string">'http://localhost:9200/_cluster/reroute'</span> -H <span class="string">'Content-Type: application/json'</span> -d  <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "commands" : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "move" : &#123;</span></span><br><span class="line"><span class="string">                "index" : "reindex-resharding-test",</span></span><br><span class="line"><span class="string">                "shard" : 0,</span></span><br><span class="line"><span class="string">                "from_node" : "192.168.0.101",</span></span><br><span class="line"><span class="string">                "to_node" : "192.168.0.102"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p>查看集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/_cluster/health?pretty'</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/_cat/indices?v'</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有shards</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/_cat/shards'</span></span><br></pre></td></tr></table></figure></li><li><p>查看unassigned shards</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/_cat/shards'</span> | grep UNASSIGNED</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇简单整理了Elasticsearch的一些常用的API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新增一个索引&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/categories/Elasticsearch/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch本地安装和常见问题</title>
    <link href="https://chaojianok.github.io/Elasticsearch%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E5%92%8C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://chaojianok.github.io/Elasticsearch本地安装和常见问题/</id>
    <published>2019-05-22T01:55:25.000Z</published>
    <updated>2019-06-04T01:18:50.065Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Elasticsearch是一个分布式、RESTful风格的搜索和数据分析引擎。目前已被各大公司广泛的引入生产使用，也已成为大数据生态的重要组成部分。</p></blockquote><p>Elasticsearch使用Java构建，不同版本的Elasticsearch对Java版本要求略有差异，可参考下图来选择Elasticsearch和Java的版本（下图来自官网<a href="https://www.elastic.co/cn/support/matrix#matrix_jvm" target="_blank" rel="noopener">Support Matrix JVM</a>）。</p><p><img src="/images/elasticsearch/Elasticsearch-and-JVM.png" alt="Elasticsearch and JVM" title="Elasticsearch and JVM"></p><h2 id="Elasticsearch本地安装"><a href="#Elasticsearch本地安装" class="headerlink" title="Elasticsearch本地安装"></a>Elasticsearch本地安装</h2><p>本地安装Elasticsearch非常简单，首先到官网<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">下载</a>Elasticsearch到本地指定目录，然后解压，进入到Elasticsearch的解压目录下，执行<code>./bin/elasticsearch</code>或<code>.\bin\elasticsearch.bat</code>(Windows)，可以加上<code>-d</code>参数让Elasticsearch在后台运行。至此，Elasticsearch就安装好了，可以通过<code>curl http://localhost:9200</code>或者用浏览器打开<code>http://localhost:9200/</code>检查是否正常启动，下图这样就表示正常启动了。</p><p><img src="/images/elasticsearch/Elasticsearch-install-view.png" alt="Elasticsearch install view" title="Elasticsearch install view"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Elasticsearch的安装非常简单，通常在安装过程中会遇到一些问题，下面这几个问题是在Ubuntu操作系统安装时经常遇到的问题。<br><em>下面的部分内容参考了<a href="http://blog.csdn.net/abcd_d_/article/details/53018927" target="_blank" rel="noopener">这篇文章</a>。</em>  </p><h4 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure><p>解决办法：<br>切换到root用户修改配置<code>/etc/sysctl.conf</code><br>添加下面配置并执行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=655360</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p><p>然后，重新启动elasticsearch，即可启动成功。 </p><h4 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max number of threads [1024] for user [elasticsearch] is too low, increase to at least [2048]</span><br></pre></td></tr></table></figure><p>解决办法：<br>修改/etc/security/limits.d/90-nproc.conf<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 1024 修改成 * soft nproc 2048</span><br></pre></td></tr></table></figure></p><h4 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: [1] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]</span><br></pre></td></tr></table></figure><p>解决办法：<br>切换到root用户，编辑<code>/etc/security/limits.conf</code>添加如下内容（其实切换到root用户直接执行<code>ulimit -n 65536</code>即可）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Elasticsearch是一个分布式、RESTful风格的搜索和数据分析引擎。目前已被各大公司广泛的引入生产使用，也已成为大数据生态的重要组成部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Elasticsearch使用Java构建，不同版本的
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/categories/Elasticsearch/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Flink简单介绍</title>
    <link href="https://chaojianok.github.io/Flink%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://chaojianok.github.io/Flink简单介绍/</id>
    <published>2019-05-21T06:35:44.000Z</published>
    <updated>2019-06-04T01:17:49.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单介绍一下Flink，部分内容来源于网络，想深入了解Flink的读者可以参照官方文档深入学习<a href="https://flink.apache.org" target="_blank" rel="noopener">Apache Flink</a>。</p></blockquote><h2 id="流计算"><a href="#流计算" class="headerlink" title="流计算"></a>流计算</h2><p>在介绍Flink之前首先说一下流计算的概念，流计算是针对流式数据的实时计算。</p><ul><li>流式数据是指将数据看作数据流的形式来处理，数据流是在时间分布和数量上无限的一系列动态数据集合体，数据记录是数据流的最小组成单元。</li><li>流数据具有数据实时持续不断到达、到达次序独立、数据来源众多格式复杂、数据规模大且不十分关注存储、注重数据的整体价值而不关注个别数据等特点。</li></ul><h2 id="Apache-Flink是什么"><a href="#Apache-Flink是什么" class="headerlink" title="Apache Flink是什么"></a>Apache Flink是什么</h2><p>Apache Flink是一个分布式流批一体化的开源平台。Flink的核心是一个提供数据分发、通信以及自动容错的流计算引擎。Flink在流计算之上构建批处理，并且原生的支持迭代计算、内存管理以及程序优化。官方称之为<code>Stateful Computations over Data Streams</code>，即数据流上有状态计算。官方对Flink的详细介绍<a href="https://flink.apache.org/flink-architecture.html" target="_blank" rel="noopener">What is Apache Flink</a>。  </p><h2 id="Flink的特点"><a href="#Flink的特点" class="headerlink" title="Flink的特点"></a>Flink的特点</h2><p>现有的开源计算方案会把流处理和批处理作为两种不同的应用类型（如Apache Storm只支持流处理，Apache Spark只支持批(Micro Batching)处理），流处理一般需要支持低延迟、Exactly-once保证，而批处理需要支持高吞吐、高效率。Flink同时支持流处理和批处理，作为流处理时输入数据流是无界的，批处理被作为一种特殊的流处理，只是它的输入数据流被定义为有界的。</p><h2 id="Flink重要基石"><a href="#Flink重要基石" class="headerlink" title="Flink重要基石"></a>Flink重要基石</h2><p>Apache Flink的四个重要基石：Checkpoint、State、Time、Window</p><ul><li>Checkpoint：基于Chandy-Lamport算法实现了分布式一致性快照，提供了一致性的语义</li><li>State：丰富的State API，包括ValueState、ListState、MapState、BoardcastState</li><li>Time：实现了Watermark机制，能够支持基于事件的时间的处理，能够容忍数据的延时、迟到和乱序</li><li>Window：开箱即用的窗口，滚动窗口、滑动窗口、会话窗口和灵活的自定义窗口</li></ul><h2 id="Flink的优势"><a href="#Flink的优势" class="headerlink" title="Flink的优势"></a>Flink的优势</h2><ul><li>支持高吞吐、低延迟、高性能的流数据处理</li><li>支持高度灵活的窗口（Window）操作</li><li>支持有状态计算的Exactly-once语义</li><li>提供DataStream API和DataSet API</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>Flink支持下面这三种最常见类型的应用示例，官网有详细的介绍<a href="https://flink.apache.org/usecases.html" target="_blank" rel="noopener">Use Cases</a>。  </p><ul><li>事件驱动的应用程序  </li><li>数据分析应用  </li><li>数据管道应用  </li></ul><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/images/flink/Flink介绍_基础架构.png" alt="Flink基础架构" title="Flink基础架构">  </p><p>Flink集群启动后，首先会启动一个JobManger和一个或多个TaskManager。由Client提交任务给JobManager，JobManager再调度任务到各个TaskManager去执行，然后TaskManager将心跳和统计信息汇报给JobManager，TaskManager之间以流的形式进行数据的传输。JobManager、TaskManager和Client均为独立的JVM进程。  </p><ol><li><p>JobManager是系统的协调者，负责接收Job，调度组成Job的多个Task的执行，收集Job的状态信息，管理Flink集群中的TaskManager。  </p></li><li><p>TaskManager是实际负责执行计算的Worker，并负责管理其所在节点的资源信息，在启动的时候将资源的状态向JobManager汇报。  </p></li><li><p>Client负责提交Job，可以运行在任何与JobManager环境连通的机器上，提交Job后，Client可以结束进程，也可以不结束并等待结果返回。  </p></li></ol><h2 id="基本编程模型"><a href="#基本编程模型" class="headerlink" title="基本编程模型"></a>基本编程模型</h2><p>Flink程序的基础构建模块是流(streams)与转换(transformations)，每一个数据流都起始于一个或多个source，并终止于一个或多个sink，下面是一个由Flink程序映射为Streaming Dataflow的示意图:  </p><p><img src="/images/flink/Flink介绍_基本编程模型.png" alt="Flink基本编程模型" title="Flink基本编程模型">  </p><h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>Flink的容错机制的核心部分是分布式数据流和<code>operator state</code>的一致性快照，系统发生故障的时候这些快照可以充当一致性检查点来退回，恢复作业的状态和计算位置等。官网有详细介绍<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/stream_checkpointing.html" target="_blank" rel="noopener">Data Streaming Fault Tolerance</a>。  </p><ul><li>Checkpointing  </li><li>Recovery  </li><li>Operator Snapshot Implementation  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单介绍一下Flink，部分内容来源于网络，想深入了解Flink的读者可以参照官方文档深入学习&lt;a href=&quot;https://flink.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Fl
      
    
    </summary>
    
      <category term="Flink" scheme="https://chaojianok.github.io/categories/Flink/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="https://chaojianok.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Scala快速入门 - 基础语法篇</title>
    <link href="https://chaojianok.github.io/Scala%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    <id>https://chaojianok.github.io/Scala快速入门-基础语法篇/</id>
    <published>2019-05-21T05:25:43.000Z</published>
    <updated>2019-05-21T08:21:30.469Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Scala是一门多范式编程语言，集成了面向对象和函数式语言的特性。本篇文章将以代码示例的形式简单介绍一下Scala语言的基础语法。</p></blockquote><h2 id="声明值和变量"><a href="#声明值和变量" class="headerlink" title="声明值和变量"></a>声明值和变量</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val声明的变量是不可变的</span></span><br><span class="line"><span class="keyword">val</span> str1 = <span class="string">"Hello World!"</span></span><br><span class="line"><span class="keyword">val</span> str2 : <span class="type">String</span> = <span class="string">"Hello World!"</span></span><br><span class="line"><span class="keyword">val</span> str3 : java.lang.<span class="type">String</span> = <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">println(str1)</span><br><span class="line">println(str2)</span><br><span class="line">println(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// var声明的变量是可变的</span></span><br><span class="line"><span class="keyword">var</span> str5 = <span class="string">"Hello World!"</span></span><br><span class="line">str5 = <span class="string">"str5 Hello World!"</span></span><br><span class="line"></span><br><span class="line">println(str5)</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Scala的数据类型包括：Byte、Char、Short、Int、Long、Float、Double和Boolean。在Scala中，这些类型都是“类”，并且都是包scala的成员，比如，Int的全名是scala.Int。对于字符串，Scala用java.lang.String类来表示字符串。<br>Scala的字面量包括：整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量和元组字面量。举例如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">123</span>      <span class="comment">//123就是整数字面量</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">3.14</span>     <span class="comment">//3.14就是浮点数字面量</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="literal">true</span>     <span class="comment">//true就是布尔型字面量</span></span><br><span class="line"><span class="keyword">val</span> i = '<span class="type">A</span>'      <span class="comment">//'A'就是字符字面量</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="string">"Hello"</span>  <span class="comment">//"Hello"就是字符串字面量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala允许对“字面量”直接执行方法</span></span><br><span class="line"><span class="number">5.</span>toString()            <span class="comment">//产生字符串"5"</span></span><br><span class="line"><span class="string">"abc"</span>.intersect(<span class="string">"bcd"</span>)  <span class="comment">//输出"bc"</span></span><br></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Scala的常用操作符：加(+)、减(-) 、乘(*) 、除(/) 、余数（%）、大于(&gt;)、小于(&lt;)、大于等于(&gt;=)和小于等于(&lt;=)等，这些操作符就是方法。<br>Scala的操作符就是方法，<code>a 方法 b</code>和<code>a.方法(b)</code>是等价的，前者是后者的简写形式，这里的<code>+</code>是方法名，是Int类中的一个方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三种写法的输出结果都是8</span></span><br><span class="line"><span class="keyword">val</span> sum1 = <span class="number">5</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> sum2 = (<span class="number">5</span>).+(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> sum2 = <span class="number">5.</span>+(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h4 id="if条件表达式"><a href="#if条件表达式" class="headerlink" title="if条件表达式"></a>if条件表达式</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(<span class="string">"x = "</span> + x)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"x = "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    println(<span class="string">"x = "</span> + x)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    println(<span class="string">"x = 0"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"x = "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scala中的if表达式的值可以赋值给变量</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">9</span></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    printf(<span class="string">"i is %d\n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Range</span></span><br><span class="line"><span class="comment">// Range可以是一个数字区间表示 i to j ，或者 i until j，左箭头 &lt;- 用于为变量 x 赋值。</span></span><br><span class="line"><span class="keyword">for</span> (a &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">   println(<span class="string">"a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (a &lt;- <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">   println(<span class="string">"a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( a &lt;- <span class="number">1</span> to <span class="number">3</span>; b &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">   println( <span class="string">"a = "</span> + a );</span><br><span class="line">   println( <span class="string">"Value of b: "</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环集合</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">val</span> numList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (a &lt;- numList) &#123;</span><br><span class="line">   println(<span class="string">"a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环过滤</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">val</span> numList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (a &lt;- numList <span class="keyword">if</span> a != <span class="number">3</span>; <span class="keyword">if</span> a &lt; <span class="number">8</span>) &#123;</span><br><span class="line">   println(<span class="string">"a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用yield</span></span><br><span class="line"><span class="comment">// 大括号中用于保存变量和条件，retVal是变量，循环中的yield会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">val</span> numList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> retVal = <span class="keyword">for</span> &#123;</span><br><span class="line">    a &lt;- numList <span class="keyword">if</span> a != <span class="number">3</span>; <span class="keyword">if</span> a &lt; <span class="number">8</span></span><br><span class="line">&#125; <span class="keyword">yield</span> a</span><br><span class="line"><span class="keyword">for</span>(a &lt;- retVal) &#123;</span><br><span class="line">   println(<span class="string">"a = "</span> + a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="定长数组，就是长度不变的数组，在Scala中使用Array进行声明，如下："><a href="#定长数组，就是长度不变的数组，在Scala中使用Array进行声明，如下：" class="headerlink" title="定长数组，就是长度不变的数组，在Scala中使用Array进行声明，如下："></a>定长数组，就是长度不变的数组，在Scala中使用Array进行声明，如下：</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个长度为3的整型数组，每个数组元素初始化为0</span></span><br><span class="line"><span class="keyword">val</span> intValueArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">3</span>)</span><br><span class="line"><span class="comment">//在Scala中，对数组元素的应用，是使用圆括号，而不是方括号，也就是使用intValueArr(0)，而不是intValueArr[0]，这个和Java是不同的。</span></span><br><span class="line">intValueArr(<span class="number">0</span>) = <span class="number">12</span></span><br><span class="line">intValueArr(<span class="number">1</span>) = <span class="number">45</span></span><br><span class="line">intValueArr(<span class="number">2</span>) = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个长度为3的字符串数组，每个数组元素初始化为null</span></span><br><span class="line"><span class="keyword">val</span> strArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line">strArr(<span class="number">0</span>) = <span class="string">"Flink"</span></span><br><span class="line">strArr(<span class="number">1</span>) = <span class="string">"Storm"</span></span><br><span class="line">strArr(<span class="number">2</span>) = <span class="string">"Spark"</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">2</span>) println(strArr(i)) </span><br><span class="line"></span><br><span class="line"><span class="comment">//Scala提供了更加简洁的数组声明和初始化方法，如下：</span></span><br><span class="line"><span class="keyword">val</span> intValueArr = <span class="type">Array</span>(<span class="number">12</span>, <span class="number">45</span>, <span class="number">33</span>)</span><br><span class="line"><span class="keyword">val</span> strArr = <span class="type">Array</span>(<span class="string">"Flink"</span>, <span class="string">"Storm"</span>, <span class="string">"Spark"</span>)</span><br><span class="line"><span class="comment">//从上面代码可以看出，都不需要给出数组类型，Scala会自动根据提供的初始化数据来推断出数组的类型。</span></span><br></pre></td></tr></table></figure><h4 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h4><p><em>可变数组需要导入包scala.collection.mutable.ArrayBuffer</em><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入ArrayBuffer包</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个可变的数组</span></span><br><span class="line"><span class="keyword">val</span> arr : <span class="type">ArrayBuffer</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">//在末尾添加一个元素</span></span><br><span class="line">arr += <span class="string">"Hadoop"</span></span><br><span class="line"><span class="comment">//在末尾添加多个元素</span></span><br><span class="line">arr += (<span class="string">"Hive"</span>, <span class="string">"Hbase"</span>)</span><br><span class="line"><span class="comment">//在末尾添加一个集合</span></span><br><span class="line">arr ++= <span class="type">ArrayBuffer</span>(<span class="string">"Scala"</span>, <span class="string">"Java"</span>)</span><br><span class="line"><span class="comment">//在指定位置添加元素</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"spark"</span></span><br><span class="line">arr.insert(<span class="number">1</span>, <span class="string">"Flume"</span>)</span><br><span class="line">arr.insert(<span class="number">1</span>, <span class="string">"Kafka"</span>, <span class="string">"Kylin"</span>)</span><br><span class="line">arr.insertAll(<span class="number">1</span>, <span class="type">ArrayBuffer</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>))</span><br><span class="line">println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新元素</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"insistent"</span></span><br><span class="line">arr.update(<span class="number">2</span>, <span class="string">"Java"</span>)</span><br><span class="line">println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定元素</span></span><br><span class="line">println(arr(<span class="number">1</span>))</span><br><span class="line">println(arr.apply(<span class="number">2</span>))</span><br><span class="line">println(arr.take(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">arr -= <span class="string">"insistent"</span></span><br><span class="line"><span class="comment">//删除集合</span></span><br><span class="line">arr -= (<span class="string">"Java"</span>, <span class="string">"Kafka"</span>)</span><br><span class="line">arr.remove(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//从1处开始删掉三个</span></span><br><span class="line">arr.remove(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//从前往后移除n个元素</span></span><br><span class="line">arr.trimStart(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//从后往前移除n个元素</span></span><br><span class="line">arr.trimEnd(<span class="number">1</span>)</span><br><span class="line">println(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr) &#123;</span><br><span class="line">  print(i + <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组转成定长数组</span></span><br><span class="line">arr.toArray</span><br><span class="line"><span class="comment">//定长数组转成变长数组</span></span><br><span class="line">array.toBuffer</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Scala是一门多范式编程语言，集成了面向对象和函数式语言的特性。本篇文章将以代码示例的形式简单介绍一下Scala语言的基础语法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;声明值和变量&quot;&gt;&lt;a href=&quot;#声明值和变量&quot; class=
      
    
    </summary>
    
      <category term="Scala" scheme="https://chaojianok.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://chaojianok.github.io/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Scala快速入门 - 环境安装篇</title>
    <link href="https://chaojianok.github.io/Scala%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>https://chaojianok.github.io/Scala快速入门-环境安装篇/</id>
    <published>2019-05-21T05:25:31.000Z</published>
    <updated>2019-05-21T08:21:11.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Scala环境安装非常简单，直接从官网下载下来解压后配置一下环境变量就可以了，本篇简单写一下操作步骤。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>到<a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala官网</a>的<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">下载页面</a>下载Scala，也可以通过命令行执行<code>wget https://downloads.lightbend.com/scala/2.12.8/scala-2.12.8.tgz</code>的方式下载。  </p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压到/usr/<span class="built_in">local</span>/share/</span></span><br><span class="line">sudo tar -zxf ~/下载/scala-2.12.8.tgz -C /usr/local/share/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入Scala解压目录</span></span><br><span class="line">cd /usr/local/share/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件夹名改为scala</span></span><br><span class="line">mv ./scala-2.12.8/ ./scala/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件权限，用hadoop用户拥有对scala目录的权限</span></span><br><span class="line">sudo chown -R hadoop ./scala/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改目录权限</span></span><br><span class="line">sudo chmod -R 0777 ./scala/</span><br></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>修改<code>vim ~/.bashrc</code>文件，在最下面添加下面两行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SCALA_HOME=/usr/local/share/scala</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure></p><p>执行<code>source ~/.bashrc</code>使生效  </p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop@ubuntu:/usr/local/share$ scala</span><br><span class="line">Welcome to Scala 2.12.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_161).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>输入<code>:quit</code>或按键盘<code>Crtl+D</code>(这个d 大小写都行，Crtl+c也行)退出Scala终端  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Scala环境安装非常简单，直接从官网下载下来解压后配置一下环境变量就可以了，本篇简单写一下操作步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载
      
    
    </summary>
    
      <category term="Scala" scheme="https://chaojianok.github.io/categories/Scala/"/>
    
    
      <category term="Scala" scheme="https://chaojianok.github.io/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Flink本地环境搭建和创建Flink应用</title>
    <link href="https://chaojianok.github.io/Flink%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%88%9B%E5%BB%BAFlink%E5%BA%94%E7%94%A8/"/>
    <id>https://chaojianok.github.io/Flink本地环境搭建和创建Flink应用/</id>
    <published>2019-05-20T07:12:21.000Z</published>
    <updated>2019-06-04T01:18:18.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇介绍一下Flink本地环境搭建和创建Flink应用。</p></blockquote><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>Flink可以在Linux、Mac OS X和Windows上运行，要求安装Java 8.x。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version "1.8.0_161"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure></p><h4 id="下载并启动Flink"><a href="#下载并启动Flink" class="headerlink" title="下载并启动Flink"></a>下载并启动Flink</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从官网下载页面 http://flink.apache.org/downloads.html 下载Flink</span></span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.8.0/flink-1.8.0-bin-scala_2.11.tgz</span><br><span class="line">tar xzf flink-1.8.0-bin-scala_2.11.tgz</span><br><span class="line">cd flink-1.8.0</span><br><span class="line"><span class="meta">#</span><span class="bash">启动本地Flink群集</span></span><br><span class="line">./bin/start-cluster.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">停止本地Flink群集</span></span><br><span class="line"><span class="meta">#</span><span class="bash">./bin/stop-cluster.sh</span></span><br></pre></td></tr></table></figure><p>启动成功后可以打开<code>http://127.0.0.1:8081</code>看到Flink的web UI，如下图所示。  </p><p><img src="/images/flink/flink-dashboard-overview.png" alt="Flink web UI" title="Flink web UI">  </p><p><em>本地安装也可以通过Flink源码构建的方式，具体操作可以参考<a href="https://www.toutiao.com/i6685975180734366220/" target="_blank" rel="noopener">Flink源码分析-源码构建</a>。</em>  </p><h4 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h4><p>使用<code>nc</code>命令监听指定端口。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nc -l 9002</span><br><span class="line"><span class="meta">#</span><span class="bash">然后随便输入点东西，比如像下面这样</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这些东西在提交SocketWindowWordCount Job之前或之后输入都是可以的</span></span><br><span class="line">hello world</span><br><span class="line">word count</span><br><span class="line">hi</span><br><span class="line">flink</span><br><span class="line">ha ha</span><br></pre></td></tr></table></figure></p><p>运行Flink测试example，这里用Flink WordCount Job来测试一下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行，指定9002端口，这个端口要和刚刚nc命令监听的端口一致</span></span><br><span class="line">./build-target/bin/flink run ./build-target/examples/streaming/SocketWindowWordCount.jar --port 9002</span><br></pre></td></tr></table></figure></p><p>查看SocketWindowWordCount Job的输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行</span></span><br><span class="line">tail -100f ./build-target/log/flink-*-taskexecutor-0-*.out</span><br><span class="line"><span class="meta">#</span><span class="bash">执行后输出如下</span></span><br><span class="line">hello : 1</span><br><span class="line">world : 1</span><br><span class="line">word : 1</span><br><span class="line">count : 1</span><br><span class="line">hi : 1</span><br><span class="line">flink : 1</span><br><span class="line">ha : 2</span><br></pre></td></tr></table></figure></p><p>也可以在Flink web UI里查看输出，如下图所示。  </p><p><img src="/images/flink/taskmanager-stdout.png" alt="Task Manager Output" title="Task Manager Output">  </p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>Flink可以使用Maven和Gradle来构建，这里只介绍使用Maven构建，要求使用Maven 3.x和Java 8.x。</p><ol><li>使用Maven创建<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用Maven创建</span></span><br><span class="line">mvn archetype:generate                              \</span><br><span class="line">  -DarchetypeGroupId=org.apache.flink               \</span><br><span class="line">  -DarchetypeArtifactId=flink-quickstart-java       \</span><br><span class="line">  -DarchetypeVersion=1.8.0                          \</span><br><span class="line">  -DgroupId=flink-demo                              \</span><br><span class="line">  -DartifactId=flink-demo                           \</span><br><span class="line">  -Dversion=0.1                                     \</span><br><span class="line">  -Dpackage=myflink                                 \</span><br><span class="line">  -DinteractiveMode=false</span><br></pre></td></tr></table></figure></li></ol><p>如果没有指定<code>groupId</code>、<code>artifactId</code>、<code>version</code>、<code>package</code>，在创建的过程中会提示定义这几个参数的值并确认，如下图所示。</p><p><img src="/images/flink/flink-demo-create.png" alt="Flink demo create" title="Flink demo create">  </p><ol start="2"><li><p>使用官方提供的快速入门脚本创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用官方提供的快速入门脚本创建</span></span><br><span class="line">curl https://flink.apache.org/q/quickstart.sh | bash -s 1.8.0</span><br></pre></td></tr></table></figure></li><li><p>使用IntelliJ IDEA等集成开发环境新建</p></li></ol><p>创建好的项目结构如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tree myflink/</span><br><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── myflink</span><br><span class="line">        │       ├── BatchJob.java</span><br><span class="line">        │       └── StreamingJob.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── log4j.properties</span><br></pre></td></tr></table></figure></p><p>接下来就可以开始开心愉快的coding啦^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇介绍一下Flink本地环境搭建和创建Flink应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本地安装&quot;&gt;&lt;a href=&quot;#本地安装&quot; class=&quot;headerlink&quot; title=&quot;本地安装&quot;&gt;&lt;/a&gt;本地安装&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="Flink" scheme="https://chaojianok.github.io/categories/Flink/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="https://chaojianok.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch源码分析 - 源码构建</title>
    <link href="https://chaojianok.github.io/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>https://chaojianok.github.io/Elasticsearch源码分析-源码构建/</id>
    <published>2019-04-30T07:38:40.000Z</published>
    <updated>2019-04-30T07:39:03.235Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍一下如何从源码构建Elasticsearch，构建Elasticsearch源码是学习和研究Elasticsearch源码的基础，有助于更好的了解Elasticsearch。  </p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><table><thead><tr><th>环境/软件</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>OS</td><td>Ubuntu 14.04 LTS</td><td></td></tr><tr><td>Gradle</td><td>5.4</td><td></td></tr><tr><td>Java</td><td>9.0.4+11</td><td>Oracle Corporation 9.0.4 [OpenJDK 64-Bit Server VM 9.0.4+11]</td></tr><tr><td>Elasticsearch</td><td>6.2</td></tr></tbody></table><h4 id="从源码构建Elasticsearch需要注意下面几个问题："><a href="#从源码构建Elasticsearch需要注意下面几个问题：" class="headerlink" title="从源码构建Elasticsearch需要注意下面几个问题："></a>从源码构建Elasticsearch需要注意下面几个问题：</h4><p>1、从源码构建Elasticsearch需要使用<a href="https://gradle.org" target="_blank" rel="noopener">Gradle</a>，因此需要确认下是否安装了gradle，可以参考<a href="https://gradle.org/install/" target="_blank" rel="noopener">官网安装文档</a>安装，安装步骤如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/gradle</span><br><span class="line">unzip -d /opt/gradle ./下载/gradle-5.4-bin.zip</span><br><span class="line">ls /opt/gradle/gradle-5.4</span><br><span class="line"><span class="meta">#</span><span class="bash">添加环境变量</span></span><br><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">在 ~/.bashrc 文件下面加上这句</span></span><br><span class="line">export PATH=$PATH:/opt/gradle/gradle-5.4/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">使新增的环境变量即时生效</span></span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">检查 gradle 是否安装配置成功</span></span><br><span class="line">gradle -v</span><br></pre></td></tr></table></figure></p><p>2、Elasticsearch编译和运行时所要求的JDK版本是不一样的，以V6.2版本为例，Runtime要求最低JDK8，Compile要求最低JDK9。不同版本的Elasticsearch应该如何确定所需JDK运行时和编译的版本呢？可以在Elasticsearch的源码里找到，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Elasticsearch &lt;= v6.3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码文件位置：buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> JavaVersion minimumRuntimeVersion = JavaVersion.VERSION_1_8</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> JavaVersion minimumCompilerVersion = JavaVersion.VERSION_1_9</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Elasticsearch &gt;= v6.4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码文件位置：buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy</span></span><br><span class="line"><span class="comment">//这段代码对应的配置文件分别是下面这两个：</span></span><br><span class="line"><span class="comment">//buildSrc/src/main/resources/minimumCompilerVersion</span></span><br><span class="line"><span class="comment">//buildSrc/src/main/resources/minimumRuntimeVersion</span></span><br><span class="line">JavaVersion minimumRuntimeVersion = JavaVersion.toVersion(</span><br><span class="line">        BuildPlugin.class.getClassLoader().getResourceAsStream(<span class="string">"minimumRuntimeVersion"</span>).text.trim()</span><br><span class="line">)</span><br><span class="line">JavaVersion minimumCompilerVersion = JavaVersion.toVersion(</span><br><span class="line">        BuildPlugin.class.getClassLoader().getResourceAsStream(<span class="string">"minimumCompilerVersion"</span>).text.trim()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>3、在终端执行构建操作前建议把终端改为bash，不然可能会有点问题。  </p><h4 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h4><p>具体步骤如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载源码</span></span><br><span class="line">git clone https://github.com/elastic/elasticsearch.git</span><br><span class="line"><span class="meta">#</span><span class="bash">进入源码目录</span></span><br><span class="line">cd elasticsearch</span><br><span class="line"><span class="meta">#</span><span class="bash">切换到一个稳定分支</span></span><br><span class="line">git checkout 6.2</span><br><span class="line"><span class="meta">#</span><span class="bash">构建源码</span></span><br><span class="line">./gradlew assemble</span><br></pre></td></tr></table></figure></p><p>看到下面输出表示构建成功了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BUILD SUCCESSFUL in 10m 15s</span><br><span class="line">505 actionable tasks: 505 executed</span><br></pre></td></tr></table></figure></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>构建成功后就可以启动Elasticsearch了，如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行</span></span><br><span class="line">./gradlew run</span><br></pre></td></tr></table></figure></p><p>启动成功后浏览器打开<code>127.0.0.1:9200</code>显示如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"node-0"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"distribution_run"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"E3qa7TIkTTGNP32WizSyXg"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.2.5"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"e38fe8a"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2019-04-25T01:27:03.655047Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.2.1"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇介绍一下如何从源码构建Elasticsearch，构建Elasticsearch源码是学习和研究Elasticsearch源码的基础，有助于更好的了解Elasticsearch。  &lt;/p&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/categories/Elasticsearch/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Elasticsearch" scheme="https://chaojianok.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Flink源码分析 - 源码构建</title>
    <link href="https://chaojianok.github.io/Flink%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
    <id>https://chaojianok.github.io/Flink源码分析-源码构建/</id>
    <published>2019-04-30T07:36:21.000Z</published>
    <updated>2019-06-04T01:18:04.877Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍一下如何从源码构建Flink，构建Flink源码是学习和研究Flink源码的基础，有助于更好的了解Flink。  </p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><table><thead><tr><th>环境/软件</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>OS</td><td>Ubuntu 14.04 LTS</td><td></td></tr><tr><td>Maven</td><td>3.0.5</td><td></td></tr><tr><td>Java</td><td>1.8.0_161</td><td></td></tr><tr><td>Flink</td><td>1.8</td></tr></tbody></table><p><em>构建前先确认下Maven和JDK版本，至少需要Maven 3.x和Java 8才能构建。</em></p><h4 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h4><p>具体步骤如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先查看下maven和Java版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash">mvn -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash">java -version</span></span><br><span class="line"><span class="meta">#</span><span class="bash">下载源码</span></span><br><span class="line">git clone https://github.com/apache/flink.git</span><br><span class="line"><span class="meta">#</span><span class="bash">进入源码目录</span></span><br><span class="line">cd flink</span><br><span class="line"><span class="meta">#</span><span class="bash">切换到一个稳定分支</span></span><br><span class="line">git checkout release-1.8</span><br><span class="line"><span class="meta">#</span><span class="bash">构建源码</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-DskipTests跳过执行测试程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Dfast跳过测试、QA插件和JavaDocs，加快构建速度</span></span><br><span class="line"><span class="meta">#</span><span class="bash">建议加上-Dfast参数，避免在构建的过程中会遇到各种各样的问题</span></span><br><span class="line">mvn clean install -DskipTests -Dfast</span><br></pre></td></tr></table></figure></p><p>看到下面输出表示构建成功了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 12:03.086s</span><br><span class="line">[INFO] Finished at: Wed Apr 24 10:38:46 CST 2019</span><br><span class="line">[INFO] Final Memory: 478M/1300M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>至此，Flink就构建成功了。  </p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>Flink已经构建好了，这里用 SocketWindowWordCount 的例子来测试一下，看看是否可以正常执行。首先按照下面的步骤启动Flink。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行</span></span><br><span class="line">./build-target/bin/start-cluster.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">执行后输出如下，表示启动成功</span></span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host ubuntu.</span><br><span class="line">Starting taskexecutor daemon on host ubuntu.</span><br></pre></td></tr></table></figure></p><p>启动成功后可以打开<code>http://127.0.0.1:8081</code>看到Flink的web UI，如下图所示。  </p><p><img src="/images/flink/flink-dashboard-overview.png" alt="Flink web UI" title="Flink web UI">  </p><p>使用<code>nc</code>命令监听指定端口。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nc -l 9002</span><br><span class="line"><span class="meta">#</span><span class="bash">然后随便输入点东西，比如像下面这样</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这些东西在提交 SocketWindowWordCount Job之前或之后输入都是可以的</span></span><br><span class="line">hello world</span><br><span class="line">word count</span><br><span class="line">hi</span><br><span class="line">flink</span><br><span class="line">ha ha</span><br></pre></td></tr></table></figure></p><p>运行Flink测试example，这里用Flink WordCount Job来测试一下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行，指定9002端口，这个端口要和刚刚 nc 命令监听的端口一致</span></span><br><span class="line">./build-target/bin/flink run ./build-target/examples/streaming/SocketWindowWordCount.jar --port 9002</span><br></pre></td></tr></table></figure></p><p>查看SocketWindowWordCount Job的输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在源码目录下执行</span></span><br><span class="line">tail -100f ./build-target/log/flink-*-taskexecutor-0-*.out</span><br><span class="line"><span class="meta">#</span><span class="bash">执行后输出如下</span></span><br><span class="line">hello : 1</span><br><span class="line">world : 1</span><br><span class="line">word : 1</span><br><span class="line">count : 1</span><br><span class="line">hi : 1</span><br><span class="line">flink : 1</span><br><span class="line">ha : 2</span><br></pre></td></tr></table></figure></p><p>也可以在Flink web UI里查看输出，如下图所示。  </p><p><img src="/images/flink/taskmanager-stdout.png" alt="Task Manager Output" title="Task Manager Output">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇介绍一下如何从源码构建Flink，构建Flink源码是学习和研究Flink源码的基础，有助于更好的了解Flink。  &lt;/p&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;
      
    
    </summary>
    
      <category term="Flink" scheme="https://chaojianok.github.io/categories/Flink/"/>
    
    
      <category term="大数据" scheme="https://chaojianok.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Flink" scheme="https://chaojianok.github.io/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chaojianok.github.io/hello-world/"/>
    <id>https://chaojianok.github.io/hello-world/</id>
    <published>2019-04-30T07:24:46.295Z</published>
    <updated>2019-04-30T07:24:46.295Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
